# Topic: Binary Search

---

## 1. Concept Overview

Binary Search is a **divide-and-conquer algorithm** used to find an element or decision boundary in a **sorted array or monotonic function**.  
Instead of checking every element, it repeatedly divides the search space in half â€” achieving **O(log n)** time complexity.

You can apply it on:
- Sorted arrays
- Monotonic sequences (increasing/decreasing)
- Answer search (when the answer space is numeric and monotonic)

---

## 2. Algorithm Intuition

We maintain two pointers: `low` and `high`.  
We check the middle element `mid = (low + high) / 2`.  
If the target is smaller, move `high = mid - 1`, else move `low = mid + 1`.  
Repeat until `low > high`.

### Template Code (Iterative - C++)
```cpp
int binarySearch(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}

Template Code (Recursive - C++)

int binarySearchRecursive(vector<int>& arr, int low, int high, int target) {
    if (low > high) return -1;
    int mid = low + (high - low) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target)
        return binarySearchRecursive(arr, mid + 1, high, target);
    else
        return binarySearchRecursive(arr, low, mid - 1, target);
}


â¸»

3. Complexity

Case	Time Complexity	Space Complexity
Best	O(1)	O(1)
Average	O(log n)	O(1)
Worst	O(log n)	O(1)


â¸»

4. Common Binary Search Patterns

Pattern 1: Standard Search

Find the index of a target in a sorted array.
ðŸ‘‰ arr[mid] == target check.

Pattern 2: Lower / Upper Bound

Find the first or last occurrence of a number (handles duplicates).

Pattern 3: Search on Answer

Binary search on result space instead of array indices.
Useful when:
	â€¢	Function is monotonic (true â†’ false or vice versa)
	â€¢	Example: â€œFind minimum time / capacity / speed / day that satisfies conditionâ€

Pattern 4: Rotated Sorted Array

Used to search elements in an array rotated at a pivot.

Pattern 5: Peak Finding / Binary Search on Function

Find local maxima/minima in arrays.

â¸»

5. Binary Search Variations (with Examples)

(a) First and Last Occurrence

Problem: Given a sorted array, find the first and last position of a target element.

Code:

int firstOccurrence(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1, ans = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] >= target) high = mid - 1;
        else low = mid + 1;
        if (arr[mid] == target) ans = mid;
    }
    return ans;
}


â¸»

(b) Search Insert Position

Problem: Find the index where an element should be inserted to maintain sorted order.

LeetCode: Search Insert Position â€“ #35

â¸»

(c) Find Square Root (Integer)

Problem: Given x, return floor(sqrt(x)) without using built-in functions.

LeetCode: Sqrt(x) â€“ #69

Idea: Use binary search on range [0, x].
If mid*mid <= x â†’ move right, else left.

â¸»

(d) Search in Rotated Sorted Array

Problem: Array is sorted but rotated at a pivot; find target index.

LeetCode: Search in Rotated Sorted Array â€“ #33

Approach:
	1.	Check which half is sorted.
	2.	Narrow search to sorted half containing the target.

â¸»

(e) Minimum in Rotated Sorted Array

LeetCode: Find Minimum in Rotated Sorted Array â€“ #153

Idea: Compare mid with rightmost element â€” shrink the unsorted half.

â¸»

(f) Binary Search on Answer

Used for problems like:
	â€¢	Allocate Books / Split Array
	â€¢	Aggressive Cows (minimum distance between cows)
	â€¢	Koko Eating Bananas
	â€¢	Capacity to Ship Packages Within D Days

Example:
LeetCode: Koko Eating Bananas â€“ #875

Approach:
Search for the minimum eating speed k (1 â†’ max(piles)) such that total hours â‰¤ H.

â¸»

6. Problem Set (with Links)

Problem	Description	Link
Binary Search	Basic search in sorted array	https://leetcode.com/problems/binary-search/
First Bad Version	Find first version that fails	https://leetcode.com/problems/first-bad-version/
Search Insert Position	Find insert index	https://leetcode.com/problems/search-insert-position/
Sqrt(x)	Integer square root	https://leetcode.com/problems/sqrtx/
Search in Rotated Sorted Array	Find target in rotated array	https://leetcode.com/problems/search-in-rotated-sorted-array/
Find Minimum in Rotated Sorted Array	Find smallest element	https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
Koko Eating Bananas	Minimum eating speed	https://leetcode.com/problems/koko-eating-bananas/
Capacity To Ship Packages	Minimum ship capacity	https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
Peak Index in a Mountain Array	Find peak element	https://leetcode.com/problems/peak-index-in-a-mountain-array/
Search a 2D Matrix	Search in 2D sorted grid	https://leetcode.com/problems/search-a-2d-matrix/


â¸»

7. Common Traps and Edge Cases

âœ… Handle integer overflow:
mid = low + (high - low) / 2 instead of (low + high)/2.

âœ… Infinite loops:
Make sure low and high are updated correctly â€” no infinite midpoint.

âœ… Duplicates:
Carefully decide whether to move high = mid or high = mid - 1.

âœ… Search boundaries:
Always validate your â€œreturnâ€ condition â€” low or high might represent the boundary you want.

â¸»

8. Step-by-Step Reasoning Template

Whenever DSA Sensei answers a question, follow this structure:

Step 1: Understand the question.
â†’ Identify if the problem involves a monotonic condition or sorted data.

Step 2: Choose correct binary search variant.
â†’ Classic search / Lower-Upper bound / Answer search.

Step 3: Define low, high, and mid correctly.
â†’ Prevent overflow and define termination condition.

Step 4: Derive complexity.
â†’ Time: O(log n), Space: O(1).

Step 5: Code with clarity and check for off-by-one errors.

â¸»

9. Visual Intuition

Imagine youâ€™re guessing a number between 1 and 100.
Each guess halves the range â€” after ~7 guesses, youâ€™ll always find the number.
Thatâ€™s binary search â€” every step cuts your search space in half.

â¸»

10. Advanced Binary Search Tricks
	â€¢	Binary search on floating values: Used in problems like â€œFind square root up to 6 decimal placesâ€.
	â€¢	Binary search with predicate function: Example:

while (low < high) {
    int mid = (low + high) / 2;
    if (condition(mid)) high = mid;
    else low = mid + 1;
}


	â€¢	Binary search on infinite sorted array: Expand bounds exponentially until target < high.

â¸»

11. Practice Checklist

âœ… Understand how binary search logic works (low/mid/high)
âœ… Implement standard binary search from scratch
âœ… Solve lower/upper bound problems
âœ… Apply to rotated arrays
âœ… Use binary search on answers (monotonic condition problems)
